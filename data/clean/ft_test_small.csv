cleaned_method,target_block,tokens_in_method
"def read(self, count=True, timeout=None, ignore_non_errors=True, ignore_timeouts=True): <TAB> try: <TAB>  <TAB> return self._read(count, timeout) <TAB> except usb.USBError as e: <TAB>  <TAB> if DEBUG_COMM: <TAB>  <TAB>  <TAB> log.info( <TAB>  <TAB>  <TAB>  <TAB> ""read: e.errno=%s e.strerror=%s e.message=%s repr=%s"" <TAB>  <TAB>  <TAB>  <TAB> % (e.errno, e.strerror, e.message, repr(e)) <TAB>  <TAB>  <TAB> ) <MASK> return [] <TAB>  <TAB> if ignore_non_errors and is_noerr(e): <TAB>  <TAB>  <TAB> return [] <TAB>  <TAB> raise",if ignore_timeouts and is_timeout ( e ) :,174
"def _cache_mem(curr_out, prev_mem, mem_len, reuse_len=None): <TAB> """"""cache hidden states into memory."""""" <TAB> if mem_len is None or mem_len == 0: <TAB>  <TAB> return None <TAB> else: <TAB>  <TAB> if reuse_len is not None and reuse_len > 0: <TAB>  <TAB>  <TAB> curr_out = curr_out[:reuse_len] <MASK> new_mem = curr_out[-mem_len:] <TAB>  <TAB> else: <TAB>  <TAB>  <TAB> new_mem = tf.concat([prev_mem, curr_out], 0)[-mem_len:] <TAB> new_mem.stop_gradient = True <TAB> return new_mem",if prev_mem is None :,165
def filtered(gen): <TAB> for example in gen: <TAB>  <TAB> example_len = length_fn(example) <TAB>  <TAB> # Checking max length boundary. <TAB>  <TAB> if max_length is not None: <MASK> continue <TAB>  <TAB> # Checking min length boundary. <TAB>  <TAB> if min_length is not None: <TAB>  <TAB>  <TAB> if example_len < min_length: <TAB>  <TAB>  <TAB>  <TAB> continue <TAB>  <TAB> # Within bounds. <TAB>  <TAB> yield example,if example_len > max_length :,117
"def search(self, query): <TAB> # ""Search.ashx?query="" + query + filterVal <TAB> if not query: <TAB>  <TAB> logger.debug(""Empty search query"") <TAB>  <TAB> return [] <TAB> logger.debug('Searching TuneIn for ""%s""' % query) <TAB> args = ""&query="" + query <TAB> search_results = self._tunein(""Search.ashx"", args) <TAB> results = [] <TAB> for item in self._flatten(search_results): <MASK> # Only return stations <TAB>  <TAB>  <TAB> self._stations[item[""guide_id""]] = item <TAB>  <TAB>  <TAB> results.append(item) <TAB> return results","if item . get ( ""type"" , """" ) == ""audio"" :",163
"def _check_script(self, script, directive): <TAB> for var in compile_script(script): <MASK> # Skip variable checks <TAB>  <TAB>  <TAB> return False <TAB>  <TAB> if var.can_contain("".""): <TAB>  <TAB>  <TAB> # Yay! Our variable can contain any symbols! <TAB>  <TAB>  <TAB> reason = ( <TAB>  <TAB>  <TAB>  <TAB> 'At least variable ""${var}"" can contain untrusted user input'.format( <TAB>  <TAB>  <TAB>  <TAB>  <TAB> var=var.name <TAB>  <TAB>  <TAB>  <TAB> ) <TAB>  <TAB>  <TAB> ) <TAB>  <TAB>  <TAB> self.add_issue(directive=[directive] + var.providers, reason=reason) <TAB>  <TAB>  <TAB> return True <TAB> return False","if var . must_contain ( ""/"" ) :",157
"def getAllDataLinkIDs(): <TAB> linkDataIDs = set() <TAB> dataType = _forestData.dataTypeBySocket <TAB> for socketID, linkedIDs in _forestData.linkedSockets.items(): <TAB>  <TAB> for linkedID in linkedIDs: <MASK> # check which one is origin/target <TAB>  <TAB>  <TAB>  <TAB> linkDataIDs.add( <TAB>  <TAB>  <TAB>  <TAB>  <TAB> (socketID, linkedID, dataType[socketID], dataType[linkedID]) <TAB>  <TAB>  <TAB>  <TAB> ) <TAB>  <TAB>  <TAB> else: <TAB>  <TAB>  <TAB>  <TAB> linkDataIDs.add( <TAB>  <TAB>  <TAB>  <TAB>  <TAB> (linkedID, socketID, dataType[linkedID], dataType[socketID]) <TAB>  <TAB>  <TAB>  <TAB> ) <TAB> return linkDataIDs",if socketID [ 1 ] :,174
"def _stderr_supports_color(): <TAB> try: <TAB>  <TAB> if hasattr(sys.stderr, ""isatty"") and sys.stderr.isatty(): <TAB>  <TAB>  <TAB> if curses: <TAB>  <TAB>  <TAB>  <TAB> curses.setupterm() <MASK> return True <TAB>  <TAB>  <TAB> elif colorama: <TAB>  <TAB>  <TAB>  <TAB> if sys.stderr is getattr( <TAB>  <TAB>  <TAB>  <TAB>  <TAB> colorama.initialise, ""wrapped_stderr"", object() <TAB>  <TAB>  <TAB>  <TAB> ): <TAB>  <TAB>  <TAB>  <TAB>  <TAB> return True <TAB> except Exception: <TAB>  <TAB> # Very broad exception handling because it's always better to <TAB>  <TAB> # fall back to non-colored logs than to break at startup. <TAB>  <TAB> pass <TAB> return False","if curses . tigetnum ( ""colors"" ) > 0 :",170
"def offsets(self): <TAB> offsets = {} <TAB> offset_so_far = 0 <TAB> for name, ty in self.fields.items(): <TAB>  <TAB> if isinstance(ty, SimTypeBottom): <TAB>  <TAB>  <TAB> l.warning( <TAB>  <TAB>  <TAB>  <TAB> ""Found a bottom field in struct %s. Ignore and increment the offset using the default "" <TAB>  <TAB>  <TAB>  <TAB> ""element size."", <TAB>  <TAB>  <TAB>  <TAB> self.name, <TAB>  <TAB>  <TAB> ) <TAB>  <TAB>  <TAB> continue <TAB>  <TAB> if not self._pack: <TAB>  <TAB>  <TAB> align = ty.alignment <MASK> offset_so_far += align - offset_so_far % align <TAB>  <TAB> offsets[name] = offset_so_far <TAB>  <TAB> offset_so_far += ty.size // self._arch.byte_width <TAB> return offsets",if offset_so_far % align != 0 :,196
"def Restore(self): <TAB> picker, obj = self._window, self._pObject <TAB> value = obj.RestoreValue(PERSIST_FILEDIRPICKER_PATH) <TAB> if value is not None: <TAB>  <TAB> if issubclass(picker.__class__, wx.FileDialog): <MASK> value = value[-1] <TAB>  <TAB> picker.SetPath(value) <TAB>  <TAB> return True <TAB> return False",if type ( value ) == list :,102