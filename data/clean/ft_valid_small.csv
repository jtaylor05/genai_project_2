cleaned_method,target_block,tokens_in_method
"def __init__(self, scale, factor, mode): <TAB> self.index = 0 <TAB> self.scale = scale <TAB> if factor is None: <TAB>  <TAB> self._log_factor = None <TAB> else: <MASK> raise ValueError(""'factor' must be >= 1.0"") <TAB>  <TAB> self._log_factor = np.log(factor) <TAB> if mode not in self.allowed_modes: <TAB>  <TAB> raise ValueError( <TAB>  <TAB>  <TAB> (""'{0}' is not a recognized mode. "" ""Please select from: {1}"").format( <TAB>  <TAB>  <TAB>  <TAB> mode, self.allowed_modes <TAB>  <TAB>  <TAB> ) <TAB>  <TAB> ) <TAB> self.mode = mode",if factor < 1.0 :,160
"def get_grab_keys(self): <TAB> keystr = None <TAB> try: <TAB>  <TAB> keys = self.display.get_grab_keys() <TAB>  <TAB> for k in keys: <MASK> keystr = gtk.gdk.keyval_name(k) <TAB>  <TAB>  <TAB> else: <TAB>  <TAB>  <TAB>  <TAB> keystr = keystr + ""+"" + gtk.gdk.keyval_name(k) <TAB> except: <TAB>  <TAB> pass <TAB> return keystr",if keystr is None :,115
"def _checkAllExamples(self, num_type): <TAB> for region_code in phonenumberutil.SUPPORTED_REGIONS: <TAB>  <TAB> numobj_py = phonenumberutil.example_number_for_type(region_code, num_type) <MASK> numobj_pb = PyToPB(numobj_py) <TAB>  <TAB>  <TAB> alt_py = PBToPy(numobj_pb) <TAB>  <TAB>  <TAB> self.assertEqual(numobj_py, alt_py)",if numobj_py is not None :,127
"def _gaf10iterator(handle): <TAB> for inline in handle: <TAB>  <TAB> if inline[0] == ""!"": <TAB>  <TAB>  <TAB> continue <TAB>  <TAB> inrec = inline.rstrip(""\n"").split(""\t"") <MASK> continue <TAB>  <TAB> inrec[3] = inrec[3].split(""|"")  # Qualifier <TAB>  <TAB> inrec[5] = inrec[5].split(""|"")  # DB:reference(s) <TAB>  <TAB> inrec[7] = inrec[7].split(""|"")  # With || From <TAB>  <TAB> inrec[10] = inrec[10].split(""|"")  # Synonym <TAB>  <TAB> inrec[12] = inrec[12].split(""|"")  # Taxon <TAB>  <TAB> yield dict(zip(GAF10FIELDS, inrec))",if len ( inrec ) == 1 :,188
"def __xor__(self, other): <TAB> inc, exc = _norm_args_notimplemented(other) <TAB> if inc is NotImplemented: <TAB>  <TAB> return NotImplemented <TAB> if inc is NotImplemented: <TAB>  <TAB> return NotImplemented <TAB> if self._included is None: <MASK> # - + <TAB>  <TAB>  <TAB> return _ComplementSet(excluded=self._excluded - inc) <TAB>  <TAB> else:  # - - <TAB>  <TAB>  <TAB> return _ComplementSet(included=self._excluded.symmetric_difference(exc)) <TAB> else: <TAB>  <TAB> if inc is None:  # + - <TAB>  <TAB>  <TAB> return _ComplementSet(excluded=exc - self._included) <TAB>  <TAB> else:  # + + <TAB>  <TAB>  <TAB> return _ComplementSet(included=self._included.symmetric_difference(inc))",if exc is None :,183
"def connection(self, commit_on_success=False): <TAB> with self._lock: <TAB>  <TAB> if self._bulk_commit: <TAB>  <TAB>  <TAB> if self._pending_connection is None: <TAB>  <TAB>  <TAB>  <TAB> self._pending_connection = sqlite.connect(self.filename) <TAB>  <TAB>  <TAB> con = self._pending_connection <TAB>  <TAB> else: <TAB>  <TAB>  <TAB> con = sqlite.connect(self.filename) <TAB>  <TAB> try: <TAB>  <TAB>  <TAB> if self.fast_save: <TAB>  <TAB>  <TAB>  <TAB> con.execute(""PRAGMA synchronous = 0;"") <TAB>  <TAB>  <TAB> yield con <TAB>  <TAB>  <TAB> if commit_on_success and self.can_commit: <TAB>  <TAB>  <TAB>  <TAB> con.commit() <TAB>  <TAB> finally: <MASK> con.close()",if not self . _bulk_commit :,182
"def renderable_events(self, date, hour): <TAB> ""Returns the number of renderable events"" <TAB> renderable_events = [] <TAB> for event in self.events: <TAB>  <TAB> if event.covers(date, hour): <TAB>  <TAB>  <TAB> renderable_events.append(event) <TAB> if hour: <TAB>  <TAB> for current in renderable_events: <TAB>  <TAB>  <TAB> for event in self.events: <MASK> for hour in range(self.start_hour, self.end_hour): <TAB>  <TAB>  <TAB>  <TAB>  <TAB>  <TAB> if current.covers(date, hour) and event.covers(date, hour): <TAB>  <TAB>  <TAB>  <TAB>  <TAB>  <TAB>  <TAB> renderable_events.append(event) <TAB>  <TAB>  <TAB>  <TAB>  <TAB>  <TAB>  <TAB> break <TAB> return renderable_events",if event not in renderable_events :,191
"def _prepare_cooldowns(self, ctx): <TAB> if self._buckets.valid: <TAB>  <TAB> dt = ctx.message.edited_at or ctx.message.created_at <TAB>  <TAB> current = dt.replace(tzinfo=datetime.timezone.utc).timestamp() <TAB>  <TAB> bucket = self._buckets.get_bucket(ctx.message, current) <TAB>  <TAB> retry_after = bucket.update_rate_limit(current) <MASK> raise CommandOnCooldown(bucket, retry_after)",if retry_after :,122
"def TryMerge(self, d): <TAB> while d.avail() > 0: <TAB>  <TAB> tt = d.getVarInt32() <TAB>  <TAB> if tt == 10: <TAB>  <TAB>  <TAB> self.set_module(d.getPrefixedString()) <TAB>  <TAB>  <TAB> continue <MASK> self.set_version(d.getPrefixedString()) <TAB>  <TAB>  <TAB> continue <TAB>  <TAB> if tt == 24: <TAB>  <TAB>  <TAB> self.set_instances(d.getVarInt64()) <TAB>  <TAB>  <TAB> continue <TAB>  <TAB> if tt == 0: <TAB>  <TAB>  <TAB> raise ProtocolBuffer.ProtocolBufferDecodeError <TAB>  <TAB> d.skipData(tt)",if tt == 18 :,150