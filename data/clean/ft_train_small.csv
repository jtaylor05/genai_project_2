cleaned_method,target_block,tokens_in_method
"def _resolve_lib_imported_symbols(self, lib, imported_libs, generic_refs): <TAB> """"""Resolve the imported symbols in a library."""""" <TAB> for symbol in lib.elf.imported_symbols: <TAB>  <TAB> imported_lib = self._find_exported_symbol(symbol, imported_libs) <TAB>  <TAB> if not imported_lib: <TAB>  <TAB>  <TAB> lib.unresolved_symbols.add(symbol) <TAB>  <TAB> else: <TAB>  <TAB>  <TAB> lib.linked_symbols[symbol] = imported_lib <MASK> ref_lib = generic_refs.refs.get(imported_lib.path) <TAB>  <TAB>  <TAB>  <TAB> if not ref_lib or not symbol in ref_lib.exported_symbols: <TAB>  <TAB>  <TAB>  <TAB>  <TAB> lib.imported_ext_symbols[imported_lib].add(symbol)",if generic_refs :,189
"def make_docs_directory(output_dir, name): <TAB> if not isdir(pjoin(output_dir, name)): <TAB>  <TAB> subprocess.run([""mkdir"", pjoin(output_dir, name)], stdout=subprocess.PIPE) <TAB> for i in range(10): <MASK> subprocess.run( <TAB>  <TAB>  <TAB>  <TAB> [""mkdir"", pjoin(output_dir, name, str(i))], stdout=subprocess.PIPE <TAB>  <TAB>  <TAB> )","if not isdir ( pjoin ( output_dir , name , str ( i ) ) ) :",121
"def assert_results(self, results, activities, msg=""""): <TAB> activity_ids = [] <TAB> extra_context = [] <TAB> for result in results: <TAB>  <TAB> if hasattr(result, ""serialization_id""): <TAB>  <TAB>  <TAB> activity_ids.append(result.serialization_id) <TAB>  <TAB> else: <TAB>  <TAB>  <TAB> activity_ids.append(result) <MASK> extra_context.append(result.extra_context) <TAB> compare_lists(activity_ids, [a.serialization_id for a in activities], msg) <TAB> if extra_context: <TAB>  <TAB> self.assertEquals([a.extra_context for a in activities], extra_context)","if hasattr ( result , ""extra_context"" ) :",164
"def for_file(cls, filename: str, modname: str) -> ""ModuleAnalyzer"": <TAB> if (""file"", filename) in cls.cache: <TAB>  <TAB> return cls.cache[""file"", filename] <TAB> try: <TAB>  <TAB> with tokenize.open(filename) as f: <TAB>  <TAB>  <TAB> obj = cls(f, modname, filename, decoded=True) <TAB>  <TAB>  <TAB> cls.cache[""file"", filename] = obj <TAB> except Exception as err: <MASK> obj = cls.cache[""file"", filename] = cls.for_egg(filename, modname) <TAB>  <TAB> else: <TAB>  <TAB>  <TAB> raise PycodeError(""error opening %r"" % filename, err) from err <TAB> return obj","if "".egg"" + path . sep in filename :",170
"def merge_dicts(source: Dict, destination: Dict) -> Dict: <TAB> for key, value in source.items(): <MASK> # get node or create one <TAB>  <TAB>  <TAB> node = destination.setdefault(key, {}) <TAB>  <TAB>  <TAB> merge_dicts(value, node) <TAB>  <TAB> else: <TAB>  <TAB>  <TAB> destination[key] = value <TAB> return destination","if isinstance ( value , dict ) :",92
"def _escape_attrib_c14n(text): <TAB> # escape attribute value <TAB> try: <TAB>  <TAB> if ""&"" in text: <TAB>  <TAB>  <TAB> text = text.replace(""&"", ""&amp;"") <TAB>  <TAB> if ""<"" in text: <TAB>  <TAB>  <TAB> text = text.replace(""<"", ""&lt;"") <TAB>  <TAB> if '""' in text: <TAB>  <TAB>  <TAB> text = text.replace('""', ""&quot;"") <MASK> text = text.replace(""\t"", ""&#x9;"") <TAB>  <TAB> if ""\n"" in text: <TAB>  <TAB>  <TAB> text = text.replace(""\n"", ""&#xA;"") <TAB>  <TAB> if ""\r"" in text: <TAB>  <TAB>  <TAB> text = text.replace(""\r"", ""&#xD;"") <TAB>  <TAB> return text <TAB> except (TypeError, AttributeError): <TAB>  <TAB> _raise_serialization_error(text)","if ""\t"" in text :",188
"def get_oldest(class_name): <TAB> """"""Get the oldest object for a specific class name"""""" <TAB> for cls, wdict in six.iteritems(live_refs): <MASK> if not wdict: <TAB>  <TAB>  <TAB>  <TAB> break <TAB>  <TAB>  <TAB> return min(six.iteritems(wdict), key=itemgetter(1))[0]",if cls . __name__ == class_name :,90
"def recursive_rm(*patterns): <TAB> """"""Recursively remove a file or matching a list of patterns."""""" <TAB> for root, subdirs, subfiles in os.walk(u"".""): <TAB>  <TAB> root = os.path.normpath(root) <TAB>  <TAB> if root.startswith("".git/""): <TAB>  <TAB>  <TAB> continue <TAB>  <TAB> for file in subfiles: <TAB>  <TAB>  <TAB> for pattern in patterns: <MASK> safe_remove(os.path.join(root, file)) <TAB>  <TAB> for dir in subdirs: <TAB>  <TAB>  <TAB> for pattern in patterns: <TAB>  <TAB>  <TAB>  <TAB> if fnmatch.fnmatch(dir, pattern): <TAB>  <TAB>  <TAB>  <TAB>  <TAB> safe_rmtree(os.path.join(root, dir))","if fnmatch . fnmatch ( file , pattern ) :",170
"def _methods(ctx, cls, inst): <TAB> while cls.Attributes._wrapper and len(cls._type_info) > 0: <TAB>  <TAB> (cls,) = cls._type_info.values() <TAB> if cls.Attributes.methods is not None: <TAB>  <TAB> for k, v in cls.Attributes.methods.items(): <TAB>  <TAB>  <TAB> is_shown = True <MASK> is_shown = v.when(inst, ctx) <TAB>  <TAB>  <TAB> if is_shown: <TAB>  <TAB>  <TAB>  <TAB> yield k, v",if v . when is not None :,130
"def save(self): <TAB> for file_field in self.files: <TAB>  <TAB> file = self.cleaned_data[file_field] <TAB>  <TAB> self.cleaned_data[file_field] = default_storage.save(file.name, file) <TAB> for name in settings.CONFIG: <TAB>  <TAB> current = getattr(config, name) <TAB>  <TAB> new = self.cleaned_data[name] <MASK> new = normalize_newlines(new) <TAB>  <TAB> if ( <TAB>  <TAB>  <TAB> conf.settings.USE_TZ <TAB>  <TAB>  <TAB> and isinstance(current, datetime) <TAB>  <TAB>  <TAB> and not timezone.is_aware(current) <TAB>  <TAB> ): <TAB>  <TAB>  <TAB> current = timezone.make_aware(current) <TAB>  <TAB> if current != new: <TAB>  <TAB>  <TAB> setattr(config, name, new)","if isinstance ( new , str ) :",192
"def order_authors(self, entry): <TAB> sort_authors = entry.author_sort.split(""&"") <TAB> authors_ordered = list() <TAB> error = False <TAB> ids = [a.id for a in entry.authors] <TAB> for auth in sort_authors: <TAB>  <TAB> results = ( <TAB>  <TAB>  <TAB> self.session.query(Authors) <TAB>  <TAB>  <TAB> .filter(Authors.sort == auth.lstrip().strip()) <TAB>  <TAB>  <TAB> .all() <TAB>  <TAB> ) <TAB>  <TAB> # ToDo: How to handle not found authorname <TAB>  <TAB> if not len(results): <TAB>  <TAB>  <TAB> error = True <TAB>  <TAB>  <TAB> break <TAB>  <TAB> for r in results: <MASK> authors_ordered.append(r) <TAB> if not error: <TAB>  <TAB> entry.authors = authors_ordered <TAB> return entry",if r . id in ids :,195
"def describe_images(self, Filters=None, Owners=None): <TAB> images = [] <TAB> for image in self.mock_ec2_images: <TAB>  <TAB> if not (Owners is None or image.get(""ImageOwnerAlias"") in Owners): <TAB>  <TAB>  <TAB> continue <MASK> continue <TAB>  <TAB> images.append(deepcopy(image)) <TAB> return dict(Images=images)","if Filters and not _matches_image_filters ( image , Filters ) :",107
"def prefetch_related(self, *args): <TAB> try: <TAB>  <TAB> for arg in args: <TAB>  <TAB>  <TAB> if isinstance(arg, str): <TAB>  <TAB>  <TAB>  <TAB> arg = FastPrefetch.make_from_field(model=self.model, field_name=arg) <TAB>  <TAB>  <TAB> elif isinstance(arg, Prefetch): <TAB>  <TAB>  <TAB>  <TAB> arg = FastPrefetch.make_from_prefetch(arg, self.model) <MASK> raise Exception(""Must be FastPrefetch object"") <TAB>  <TAB>  <TAB> if arg.field in self.prefetches: <TAB>  <TAB>  <TAB>  <TAB> raise Exception(""Prefetch for field '%s' already exists."") <TAB>  <TAB>  <TAB> self.prefetches[arg.field] = arg <TAB> except Exception as e:  # noqa <TAB>  <TAB> traceback.print_exc() <TAB> return self","if not isinstance ( arg , FastPrefetch ) :",196
"def niap_scan(rule, extensions, paths, apath, ignore_paths=None): <TAB> """"""NIAP scan."""""" <TAB> try: <TAB>  <TAB> if not apath: <TAB>  <TAB>  <TAB> apath = """" <TAB>  <TAB> options = { <TAB>  <TAB>  <TAB> ""choice_rules"": rule, <TAB>  <TAB>  <TAB> ""alternative_path"": apath, <TAB>  <TAB>  <TAB> ""choice_extensions"": extensions, <TAB>  <TAB>  <TAB> ""ignore_paths"": ignore_paths, <TAB>  <TAB>  <TAB> ""show_progress"": False, <TAB>  <TAB> } <TAB>  <TAB> scanner = Scanner(options, paths) <TAB>  <TAB> res = scanner.scan() <MASK> return res[""choice_matcher""] <TAB> except Exception: <TAB>  <TAB> logger.exception(""NIAP scan"") <TAB> return {}",if res :,176
"def secret_generator(self, string, *args, **kwargs): <TAB> # There may be multiple strings on the same line <TAB> results = self.regex.findall(string) <TAB> for result in results: <TAB>  <TAB> # To accommodate changing self.regex, due to different filetypes <MASK> result = result[1] <TAB>  <TAB> entropy_value = self.calculate_shannon_entropy(result) <TAB>  <TAB> if entropy_value > self.entropy_limit: <TAB>  <TAB>  <TAB> yield result","if isinstance ( result , tuple ) :",121
"def encode(obj, encoding=""utf-8"", errors=""strict""): <TAB> encoder = __encoder(encoding) <TAB> if encoder: <TAB>  <TAB> result = encoder(obj, errors) <MASK> raise TypeError(""encoder must return a tuple (object, integer)"") <TAB>  <TAB> return result[0]","if not ( isinstance ( result , tuple ) and len ( result ) == 2 ) :",86
"def greetings(request): <TAB> if request.method == ""POST"": <TAB>  <TAB> form = HelloForm(request.POST) <MASK> first_name = form.cleaned_data[""fname""] <TAB>  <TAB>  <TAB> last_name = form.cleaned_data[""lname""] <TAB>  <TAB>  <TAB> return HttpResponse(""Hello, {} {}"".format(first_name, last_name)) <TAB>  <TAB> else: <TAB>  <TAB>  <TAB> return render(request, ""home.html"") <TAB> return render(request, ""home.html"")",if form . is_valid ( ) :,125
def logic(): <TAB> while 1: <TAB>  <TAB> yield a <TAB>  <TAB> var = 0 <TAB>  <TAB> i = len(a) - 1 <TAB>  <TAB> while i >= 0: <MASK> var += 1 <TAB>  <TAB>  <TAB> i -= 1 <TAB>  <TAB> out.next = var,if a [ i ] == 1 :,74
"def reconfigure(self, user_config) -> None: <TAB> if user_config: <MASK> raise ValueError( <TAB>  <TAB>  <TAB>  <TAB> ""argument func_or_class must be a class to use user_config"" <TAB>  <TAB>  <TAB> ) <TAB>  <TAB> elif not hasattr(self.callable, BACKEND_RECONFIGURE_METHOD): <TAB>  <TAB>  <TAB> raise RayServeException( <TAB>  <TAB>  <TAB>  <TAB> ""user_config specified but backend "" <TAB>  <TAB>  <TAB>  <TAB> + self.backend_tag <TAB>  <TAB>  <TAB>  <TAB> + "" missing "" <TAB>  <TAB>  <TAB>  <TAB> + BACKEND_RECONFIGURE_METHOD <TAB>  <TAB>  <TAB>  <TAB> + "" method"" <TAB>  <TAB>  <TAB> ) <TAB>  <TAB> reconfigure_method = getattr(self.callable, BACKEND_RECONFIGURE_METHOD) <TAB>  <TAB> reconfigure_method(user_config)",if self . is_function :,190